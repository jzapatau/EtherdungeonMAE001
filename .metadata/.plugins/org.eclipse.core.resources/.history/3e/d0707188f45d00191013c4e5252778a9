// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package MAE1Project;

//------------------ IMPORT MODULES ---------------------------//

//No modules to import

// TODO: implement encounter to be able to work with multiplayer mode
// and also account for the virtuality of the users....


/************************************************************/
/**
 * @author Felix Zapata
 * Date: 3/04/2019
 * 
 * Class Encounter is in charge of commanding the dynamics of
 * any confrontation between two teams.
 */
public class Encounter {
	
	// ------------------ PROPERTIES ------------------------ //
	

	/**
	 * User is a User instance for the
	 * Heroes in the confrontation.
	 */
	private User<Hero> userHero;
	
	/**
	 * UserMonster is a USer instance for the
	 * Monster in the confrontation.
	 */
	private User<Monster> userMonster;

	/*
	 * ui is the UI instance required to perform the command.
	 */
	public UI ui;
	
	//----------------------- METHODS ---------------------------//

	/**
	 * Class constructor
	 * @param userHero: User of heroes
	 * @param userMonster: User of monsters
	 */
	public Encounter(User<Hero> userHero, User<Monster> userMonster) {
		// Set the properties of the object
		this.setUserHero(userHero);
		this.setUserMonster(userMonster);
		this.setUi(UI.INSTANCE);
	}
	
	/**
	 * runEncounter is the method which accounts for executing the
	 * encounter between the two parties.
	 */
	public void runEncounter() {
		// First Print to Screen the Encounter
		this.presentEncounter();
		
		// Initialize a counter to keep track of the encounter
		int counter = 0;
		
		// Run the encounter
		while (!this.isFinished()) 
		{
			// If even run Turn for the Hero team
			if (counter % 2 == 0){
				// Create newTurn and run it
				Turn<Hero, Monster> newTurn = new Turn<Hero, Monster>(userHero.getTeam(), userMonster.getTeam(), !(userHero.isVirtual()));
				newTurn.runTurn(true);
			}
			else {
				// draft monster following participation Queue
				// TODO: implement TypeException Exception handling
				// Create newTurn and run it
				Turn<Monster, Hero> newTurn = new Turn<Monster, Hero>(userMonster.getTeam(), userHero.getTeam(), !(userHero.isVirtual()));
				newTurn.runTurn(false);
			}
			
			// Update both teams
			teamHero.update();
			teamMonster.update();
			
			// Update the counter to move on to next turn
			counter++;
		}
		
		// Close encounter on screen to move on
		closeEncounter();
	}
	
	/**
	 * presentEncounter() is a private method which handles the presentation
	 * of the objects at the beginning of the Encounter.
	 */
	private void presentEncounter() {
		// Collect both teams strings and merge them accordingly
		String out = "";
		out += "\n------------------- NEW FIGHT!!!!! GET READY!!!!!! ----------------------\n";
		out += "Featuring: \n";
		out += this.getTeamHero().toString();
		out += "\n\n VERSUS \n\n";
		out += this.getTeamMonster().toString();
		out += "\n------------------- LET THE FIGHT TO DEATH BEGIN!!!! ---------------------\n";
		
		// Print the object to the screen
		this.getUi().printToScreen(out);
	}
	
	/**
	 * closeEncounter() is a private method which handles the presentation of the encounter
	 * of the objects at the ending of it. It presents the winner team.
	 */
	private void closeEncounter() {
		// Prepare the String
		String out = "";
		out += "\n ------------------------ FIGHT FINISHED!!!!! ----------------------- \n";
		out += "Team winner: \n";
		
		// Check if encounter isWon
		if (isWon()) {
			out += teamHero.toString();
		}
		else {
			out += teamMonster.toString();
		}
		
		// Print the string to the screen
		ui.printToScreen(out);
	}
	
	/**
	 * runNewTurnHero implements the Turn for the Hero
	 */
	
	/***************** GETTERS AND SETTERS ******************/

	public boolean isWon() {
		return !(teamHero.getMembers().isEmpty());
	}

	public boolean isFinished() {
		return (teamHero.getMembers().isEmpty() || teamMonster.getMembers().isEmpty());
	}

	public User<Hero> getUserHero() {
		return userHero;
	}

	public void setUserHero(User<Hero> userHero) {
		this.userHero = userHero;
	}

	public User<Monster> getUserMonster() {
		return userMonster;
	}

	public void setUserMonster(User<Monster> userMonster) {
		this.userMonster = userMonster;
	}

	public UI getUi() {
		return ui;
	}

	public void setUi(UI ui) {
		this.ui = ui;
	}
	
	
};
